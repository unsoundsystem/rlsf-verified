= 現状
:source-highlighter: pygments

時系列順に調査・実装などについて、書いていきます。
調査するべき項目が生じたときは `Q: ...` として、後に明らかになれば言及します。

== 2024/09/26以前

=== Refinedrustの適用可能性について

==== フロントエンド

Radiumの表現力は十分に見えるが､フロントエンド・Coqによる形式化に手を加える
必要がある。RustからCoqへの変換フロントエンドの機能がrlsfの実装をそのまま扱
うには、不十分だが等価な実装に置き換えることで対応可能だと思われる。
(ref. `refinedrust-dev/case_studies/tests`)

==== Radiumの表現力

元論文ではunsafeな実装やreborrowなどが扱えるとされており、rlsfの実装を検証す
るのに十分な表現力があるように見える。

==== 標準ライブラリの形式化状況

標準ライブラリに関する形式化などは、まだほとんどなされていない。`shim` とい
う仕組みが用意されていて、手動で書いたRadium/Coqの表現を使った検証が可能。

=== ビット演算の形式化

TLSFではビット演算を多用するため、Rustによるビット演算の実装を検証できるこ
とが望ましい。RefinedRustでは、現在TLSFで用いるビット演算に関する形式化がさ
れていないため実装する。

==== 方針

Rustのプリミティブ整数型では、TLSFで扱う `wrapping_add` / `saturating_add`
/ `rotate_right` のような関数はllvm intrinsicsへコンパイルされ、
footnote:[llvm_fshr, https://llvm.org/docs/LangRef.html#llvm-fshr-intrinsic]
Rustの意味論を使って検証することができないため、RefinedRustの `only_spec` アノ
テーションで形式仕様のみ記述する。 `only_spec` がついたオブジェクトはradiumコー
ドが生成されず、仕様のみ生成される。

また、Rustのコンパイラプラグインの事情でプリミティブ型へのメソッドを扱うことが
難しそうだったため、footnote:[rustc_plug, rustc_hirでdef_idを取得できないように見える]
プリミティブへのメソッド呼び出しを通常の関数でラップした上で、
`rr::only_spec` アノテーションをしている。

RefinedRust/Radiumでは、Rustの整数型はCoqの(無限長の)整数型 `Z` 上の制限と
して形式化されている。Coqの `Z` は正の数をバイナリ表現で形式化した
`positive` 型を使って以下のように定義されているため、 `Z.land` / `Z.lor` の
ような論理演算が定義されている。

[source, coq]
----
Inductive Z : Set :=
    | Z0 : Z
    | Zpos : positive -> Z
    | Zneg : positive -> Z.
----

`Z` については、様々な数学的成果が形式されているが、ここではビット演算の仕様を
記述するため、 `Z.log2` のような数学的な語彙ではなく `Z.shiftr` のような論理演
算に関する形式化を使う。 `Z.log2` のような語彙を使うと、TLSFのインデックス計算
で用いる性質をそのままエンコードしてしまい、形式化の信頼性が損なわれる。
footnote:[完全な私見なので、検討の余地があります]

==== rotate_right

シフトするビット数が負になり得るケースを含む定義を上手くする方法を考察中。

定義の妥当性を保証する仕様として、n bitシフトしたときにm bit目(0-indexed)が
`(m - n + ws) mod ws` に移動していてほしい(ref. `Zrotate_right_spec` )

==== count_(leading|traling)_zeros

0になるまで右シフトする定義が具体的な値に対する計算量が大きすぎたので、代わりに
与えられた幅だけ1ビットづつテストしていく定義を与えた。

=== RefinedRustを使った検証コードベースに外部のCoqライブラリを導入する

`cargo-refinedrust` に手を加えて、 `RefinedRust.toml` にオプション `external_coq_libs` を追加

=== QuickChickを導入

Coqのproperty-based testingができるQuickChickを導入。証明に入る前に定義を吟味する際に便利。

== 2024/09/27

* 開発環境を自前の `flake.nix` に移行することを試みた
    ** Coqのバージョン、コンパイルしたOCamlコンパイラのバージョンが一致しているにもかかわらず、以下のようなエラーが発生する

    Compiled library stdpp.numbers (in file /nix/store/nsbxf0vixraln8nlsi4frg5kxrpcddmy-coq8.17-stdpp-4be5fd62ddbd5359f912e2cebb415b015c37e565/lib/coq/8.17/user-contrib/stdpp/numbers.vo) makes inconsistent assumptions over library Coq.Init.Ltac

    ** 現在は `refinedrust-dev/flake.nix` のdevShellに依存を追加して使っている
* 本リポジトリのドキュメント・ `rr-ex` のcoqdocをwebサイトにした
* [[rotate_shiftに関する形式化の方針転換]]rotate_rightに関する補題を各ビット幅に具体化して示すように方針を変えた
    ** 理由: 実際に使うビット幅は限られるため
    footnote:[余談: 任意幅に一般化するなら、各幅についてlist boolとの間に全単射を構成したほうが良さそう。
            stdppやsailなどcircular shiftの形式化を扱う実装を確認したが、listを使った実装になっていた]
        *** Z上の制限として固定ビット幅の整数に関するビット操作を扱っているVST/CompCertやVellvmでも同様の方針をとっているように見える

== 2024/10/02

* xref:rotate_shiftに関する形式化の方針転換[この方針]にしたがって定義を簡素化した

== 2024/10/03

* rotate shift/count leading zeros周りの補題( `count_leading_zeros_usize_spec` / `Zrotate_right_usize_spec` )の証明を進めた

== 2024/10/04

* インデックス計算の補題の証明を進めた
* [[bitop_min_ex]]ビット操作を扱うRustコードの検証のminimal exampleを作った→上手く動かない
    ** `rr::spec_only` でつけた形式仕様がRefinedRustの生成するsidecondisionを満たせていない
* 抽象仕様(`rr-ex/coq/models.v`)のドキュメントを少し書いた
* [[spec_only_sidecond]]Q: `rr:spec_only` でつけた形式仕様に要求されるsidecondisionに関して調査する

== 2024/10/07

* A: xref:bitop_min_ex[ビット操作を扱うコードの検証例]を直した(xref:spec_only_sidecond[これ]は勘違い)
    ** 原因: アノテーションの使い方が間違っていた
        *** 関数の引数に関する事前条件の指定には `rr::args` を使うべき
* Q: `rotate_right` のシフト幅が負の場合の扱い
    ** 厄介な点: `u32` を符号付きとして暗黙的に扱っている(`assert_eq!(2, 1usize.rotate_right(u32::MAX))`)
    ** Coq側で `i32` として解釈した分シフトするようにして、事後条件も `usize` の取る値の範囲でシフト幅の正負が変わることを明示する

== 2024/10/10

* RefinedRustのAllocator APIに関する形式化を調査した
    ref. xref:./refinedrust.adoc[refinedrustに関するメモ]
* 簡略化した `map_floor` の検証
    ** template tacticが失敗するのでデバッグしていた
    ** RefinedRustのspecでタプルを扱う方法がわからない
* [[tuple_treatment]] Q: タプルの扱い/どんな型でrefineできるのか
* `block_size_range_not_overwrap` の証明を進めた

== 2024/10/11

* A: xref:tuple_treatment[タプルの扱い]についてCoqの項 `hlist (place_rfn {Coqの型})` でrefineできることがわかった
* 簡略化した `map_floor` の検証: RefinedRust側の問題は概ね解決した
* `block_size_range_not_overwrap` の証明を進めた( `SLI` が `SLLEN` と混同されていた)
* 抽象仕様の検討
* Q: 割当済みブロックの追跡
    ** 他の検証プロジェクトを調査する

== 2024/10/17

* `BlockHdr` / `FreeBlockHdr` / `Tlsf` のアノテーション・変換fix
    ** `rr_frontend` が未対応な部分は `sed` の力を借りている
* ビットマップとfreelistの整合性に関する不変条件を追加
* Q: const parametersの扱い
    ** refinedrustでも単純なジェネリクスが扱えるが、const parametersが扱えるかの検証
* Q: 再帰的な構造に対する述語の書き方
    ** `first_free[fl][sl].next_free` に関する言明

== 2024/10/18

* ビット操作周りはなんとかなりそう
    footnote:[もう少し形式化を成熟させて証明を完了させる必要はあるがRefinedRustで検証を続けるために本質的な制約は無さそうの意]
  なので、先にraw pointerを多用するコードが実際に検証できることを確かめたい
* rawポインタを扱うプログラムの検証の実験,リンクリストの結合で `&T` から `*const T` に変換する部分の推論が上手く行かない
    ** ローカル変数にアノテーションが出来ないためsideconditionが残ったと思われる cf. `rr_ex::silly`
* `NonNull` APIの形式仕様
* `core::mem::replace` の形式仕様
* 単純化した `Tlsf::link_free_block` をつかってリンクリストの検証方法を確かめる(wip)
    ** link listは以下のような形で実現できそう？
        `l ↦ v` の `v` はただのバイト列で、layoutやrefinementの条件を足すことで構造体が格納されていることを言えそう (ref. `has_layout_val` )
        footnote:[余談: VSTだと直感的に `l ↦ struct t { ... fields }` に近い書き方ができるのでハマってしまった]
[quote]
----
l ↦ v * v @ struct_t ... field ...
   * l' ↦ v' * to_val_or_somthing l' @ field
----

== 2024/10/21

* `ptr::write` 後 `ptr::read` する関数の検証が出来ない原因の調査
    ** rlsfでは `mem::replace` を使っているが中身が `ptr::read` / `ptr::write` なのでこれは問題
* Q: [[weak_ptr_read_spec]] `type_of_ptr_read` ( `theories/rust_typing/shims.v` )が弱すぎる
    ** `ptr::read` の仕様に該当するものだが、事後条件で読み出した値の `uninit` が返ることになっている
        *** `ptr::write` の事後条件から情報が減っている
    ** enumの初期化周りの都合らしい
    ** workaroundの検討
        *** 強い条件をadmitしてshimとして使う
        *** 特定の構造体について同様の関数を用意してよりつよい条件を証明する→この方針で進める
        *** `value_t` (バイト列として解釈するための型)を使ったインタフェースをラップして使えないか
        *** `mem::replace` を使っている限り `&mut` を持っているので大丈夫な可能性...
* [.line-through]#特定の構造体について同様の関数を用意して証明する#
    ** `refinedrust.examples.rr_ex.generated` と `extras` のtheoryが循環参照になる
        *** `post_generation_hook` で `coq/shims.v` を `generated/` にコピーする

== 2024/10/24

* A: xref:weak_ptr_read_spec[ `ptr::read` の仕様が弱い問題 ] についてrlsfでは
  `mem::replace` が用いられており、 `&mut` が引数なので所有権に関する仮定が使え
  るので問題にならない
* `mem::replace` の検証
* Q: `NonNull` を使った検証でフロントエンドがパニックする
    ** A: フロントエンドの制約で再帰的な出現が扱えない
    ( `*const T` が許されているので `NonNull<T>` も大丈夫かと思ったが違った)
* [[arrays_unsupported]] Q: 静的な配列アクセスがサポートされていない？
    ** `case_studies/minivec` では `*mut T` へ明示的にアドレス計算をして要素にアクセスしている
    ** workaround: [.line-through]#const fn で要素アクセスをラップして、only_spec#
    ** 配列のリテラルを含むコードを自動的にスキップするのか上手く行かなかった。
    ** `*mut T` に変換して扱うか、RefindeRust側で配列の要素アクセスを扱えるようにする必要がある

== 2024/10/25

* xref:arrays_unsupported[静的な配列アクセスが扱えない問題]のworkaroundの調査
    ** A: refinedrust側の拡張を考えつつ、 `*mut T` で代替する
* 配列の `*mut T` への書き換えとアノテーション(wip)

== 2024/10/31

* 配列がサポートされていない問題のworkaround中
    ** `*mut T` はRefinedRustの型システムでは [.line-through]# `loc` として扱われ、型情報が消えるため#
        アノテーションが適切でなかった
        rr_frontendがTに関連する定義を解析してくれず、手動でshimなどをインポートする必要がある
    **  TODO: 生成されたスペック中の `std_option_Option_ty` の定義をファイルの上の方に持ってくる
* `self.first_free` をrefineするCoqの型 `block_matrix` を修正

== 2024/11/01

* [[raw_deref]] Q: raw pointer dereferenceの事前条件に関する調査
    ** かなり単純な例(`silly_deref`)についても自動化が働かず、手動で証明する方法を調査している
        *** 適切な事前条件をRefinedRustの語彙で表す方法を調査している(アノテーションは `main.rs` を参照)
[source,rust]
----
unsafe fn silly_deref(x: *mut usize) -> usize {
    *x
}
----
    ** `typed_place` が残るので関連する補題などを調査中

== 2024/11/06

* A: xref:raw_deref[raw poitner dereferenceの事前条件について]
  `silly_deref` の事前条件として `ptr::read` の強めた仕様を指定したらほぼ自動で証明してくれた
  ** [.line-through]#空虚かもしれない#

[source,rust]
----
#[rr::params("l" : "loc", "vs", "z" : "Z")]
#[rr::args("l" @ "alias_ptr_t")]
#[rr::requires(#iris "l ◁ₗ[π, Owned false] PlaceIn vs @ (◁ value_t (st_of (int usize_t))) ∗ vs ◁ᵥ{π} z @ (int usize_t)")]
#[rr::returns("z")]
unsafe fn silly_deref(x: *mut usize) -> usize {
    *x
}
----

== 2024/11/07

* 構造体のフィールドのraw poitner dereferenceについて調査中
    ** `l ◁ₗ[π, Owned false] -[b; pf; nf] @ (◁ FreeBlockHdr_ty)` のようにして仕様はかけた
    ** `(*x).next_free = None;` の事後条件として `l ◁ₗ[π, Owned false] -[b; pf; #None] @ (◁ FreeBlockHdr_ty)`
        を証明したい
        *** `ptr::write` のshimを見ても事前条件は十分に見えるので、手動で証明する方法を探している
* Q: raw pointer越しのフィールド更新の事後条件の証明方法
* 抽象仕様の分離論理へのエンコードに関するメモを書いた

== 2024/11/08

* 基本的な機能の実現に時間が掛かりそうなため、一度RefinedRustから離れて他の方法を検討する
    ** 候補1: Verus
        *** 既にmimallocの検証に使われており、他のケーススタディも豊富なため
    ** 候補2: C言語実装をVSTで検証する
        *** VSTを使った検証プロジェクトは多く、アロケータについても先行研究がある
* verusによるmimallocの検証コードを読んでいた

== 2024/11/11

* Verusのmimalloc検証コード読みつづき
* verusによるリンクリストの検証例を作っていた

== 2024/11/13

* verusによる単方向リンクリストの検証例を作った
* ハマった点: 以下のエラメッセージがわかりにくかった
    ** 実際には以下のスペックは間違っていて、正しくは `... =~= old(self)@.push(v)` だった点の修正
    `self@` と `old(self)@` の同じ要素を含んでいる部分に関するアサーションを追加すれば解決した
    ** `struct` の修飾子や `spec` の `open` / `closed` が関係しているかと思ってしまった
[rust,source]
----
error: assertion failed
  --> ./singly_linked_list_trivial.rs:77:28
   |
77 |                     assert(self@ =~= seq![v].add(old(self)@));
   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assertion failed

note: diagnostics via expansion:
      self.view() =~= empty().push(v).add(old(self).view()) 
          datatype is opaque here
----

== 2024/11/14

* Verusのtokenized state machineに関する調査
    ** 状態器械の定義とRustのコードがそれを満たしていることを保証する機能
    ** 並行プログラムも検証できる
* 使用例がマクロを多用しているのでminimal working exampleを作っている
    ** cf. `verus/source/rust_verify/state_machines/top_sort_dfs`
    ** [[atomic_inv]] Q: `struct_with_invariant!` マクロなしで `Instance` と実装を適切に関連付ける方法がわからない
        *** `verus-ex/tsm_silly.rs`

== 2024/11/18

* xref:atomic_inv[アトミック型でラップされてないとInvariantが開けない]
* Verusの基礎について書き進めたxref:./verus.adoc[verus.adoc]
