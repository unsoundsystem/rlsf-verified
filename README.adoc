= TLSFアロケータのdeductive verification

* Rust実装の正当性を保証したい

== 現状の方針

* RefinedRustの適用を試みる
    ** 非技術的な動機
        *** safety criticalな利用目的なので出来るだけfoundationalな検証を目指したい
        *** 自分のスキルセットなどを鑑みて定理証明による手法が使いたい

== 現状

* Radiumの表現力は十分に見えるが､フロントエンド・Coqによる形式化に手を加える必要がある
    ** refinedrust-dev/case_studies/testsを見る限り、多少手を加える必要はあるかもしれないがrlsfのコア部分を扱うのには十分
    ** 元論文ではunsafeな実装やreborrowなどが扱えるとされているので、rlsfの仕様記述・検証に使えそう
    ** しかし、標準ライブラリに関する形式化などは、まだほとんどなされていない
* 標準ライブラリに関する検証状況を調査する cf. `refinedrust-dev/stdlib`
    ** 特にusizeなどはビット操作で標準ライブラリの関数を多用しているので、注意する必要がある
        *** -> rlsfで用いられるusizeのビット操作は問題なくCoq.Z.BinInt周りの補題などに還元できそう
    ** その他の標準ライブラリに関する形式化などは、まだほとんどなされていない
    ** `std::ptr::NonNull` は特別に手動でメソッドなどが形式化されてユーザーからも検証時に利用できる ref. `theories/rust_typing/shim.v`
* プリミティブ型に関する操作の形式仕様を拡張する方法を探す
    ** primitive typeへのメソッド呼び出しの変換が難しそう（rustc_hirでdef_idを取得できないように見える)
        *** workaround: 使うのはu32/usizeへのビット操作で実態はllvm intrinsicsなので検証できないし、関数呼び出しでラップして `rr::only_spec` をつければ良さそう
* Z上にrotate_shift(nbit width)を形式化する
    ** 他のビット演算を含め、Z.某を使えばできるがRefinedRustのプロジェクトで外部のCoqライブラリを導入する方法がなさそう
* 外部のCoqライブラリを導入できるようにした
    ** `RefinedRust.toml` にオプション `external_coq_libs` を追加
* QuickChick(property based/mutation testing)を導入した

== TODO

* count leading/trailing zerosの形式仕様
    ** usizeなどが単にZの制限なので、cherry-pickingに注意
* rotating shiftに関する補題の追加
    ** testbit x n iff testbit x (shifted-loc)
* zhang et.al.の不変条件をrlsfの実装に合うように翻訳してみる
    * インデックス計算の形式化
* 検証の対象とする性質の検討
    ** Rustのアロケータとして要求される仕様について検討する
* `Tlsf::allocate` / `Tlsf::deallocate` に絞って正当性を考えて・スペックを書き始める
    ** インフォーマルに検証の対象とする仕様などに関することをまとめる
* rlsfの実装を読む
    ** `crates/rlsf/src/tlsf.rs` を中心にインフォーマルに正当性を考えてみる
* `crates/rlsf/src/tlsf.rs` を現在のフロントエンドで扱える範囲に、書き換える
* RefinedRustに関する調査
    ** 論文を精読/Coqの形式化を読む
    ** 文書にまとめる

== references

* https://plv.mpi-sws.org/refinedrust/[RefinedRust webpage]
* https://github.com/yvt/rlsf/tree/main[rlsf repository]
* https://iris-project.org[Iris webpage]
