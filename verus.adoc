= Verusによるmimallocの検証
:source-highlighter: pygments

* https://github.com/verus-lang/verified-memory-allocator

== Verus

Verusは、Rustに仕様記述言語とその証明のための言語を加えたRustコードベースの形式検証のための言語です。

* Rustのコードベースに対する静的な保証の拡大
* メモリ操作に関する低レイヤのプラクティスを扱える
    ** メモリ操作に関する推論は主にRustの型検査器によって行われる
* SMTによって証明の大部分が自動化される設計

=== TCB

Verusによって検証されたコードの正当性は、以下を仮定した上でのものとなる。

* SMTLIBへの変換の適切さ
* Rustの型検査器の正当性

== 検証ツールの導入

https://github.com/verus-lang/verus/blob/main/INSTALL.md
playground: https://play.verus-lang.org/?version=stable&mode=basic&edition=2021

== Verusの基礎

Verusを使った検証は大まかに次の仕事からなる、まず(1)保証したい性質を表す述語を定義し、
(2)その性質を満たしてほしいRustのオブジェクト(e.g. 関数, `struct`)に対してアノテーションする、
最後に検査器を実行し、制約が満たされていない場合は(3)証明が成功するように検査器にヒントを与える。
これらを実現するにはRustの言語仕様以上の語彙・構文が必要になるが、Verusは静的保証を提供するためRustコードに変換する際にこうした要素を全て取り除く。
従ってVerusの構文にはモードとして以下のような区別・役割が存在する。

* spec: プログラムに関する性質を表すためのコード
* proof: 検査器にヒントを与え、コードが与えた仕様を満たしていることを証明するためのコード
* exec: 実際に実行されるコード

これらのコードは必ず別々に書かれる訳ではなく、以下のような制約のもとで書くことが許されている。

[width="50%",frame="topbot"]
|====
|mode              |spec    |proof  |exec
|spec内に存在可    |o       |x      |x
|proof内に存在可   |o       |o      |x
|exec内に存在可    |o       |o      |o
|====


* mode: exec/spec/proof
* コンパイル時に消える証明用コードを書きながらassertでソルバにヒントを与えて事後条件を証明していく
* memory safetyに関する注意
    ** Verusは自動的にUBが無いことを保証したりはしない
    ** Verusは言語としてRustのスーパーセットであり、当然unsafe blockが書ける
    ** memory safetyは仕様記述と関数呼び出し時の事前条件の充足を保証することで実現される

== 検証フローの例: 単方向リンクリスト

Verusによって低レイヤのプラクティスを扱えることを示すために、raw pointerを用いた単方向リンクリストの実装と検証の例を取り上げる。

* 単純なユースケース向けのraw pointerをラップした型である `PPtr` を用いた単方向リンクリストの実装・検証

== mimallocの概観

=== データ構造

各スレッドごとに以下のような構造が関連付けられる
(こちらのFig. 1がわかりやすいhttps://www.microsoft.com/en-us/research/uploads/prod/2019/06/mimalloc-tr-v1.pdf)

* Heap
    ** pages_direct: 空いているPageへのポインタのリスト(1MB以下のアロケーション用のfast path)
    ** pages: Heap内の全てのページのサイズ別リストへのポインタ
* Page: ページ内の空きリスト
* Block: ページ内の割当単位,ページごとに固定長
* Segment: Page構造体のリストなどのメタデータを含む。実際のページの並びの先頭に埋め込まれる。

== challenges

verusをメモリアロケータの検証に用いる際に問題となりそうな部分について、
mimallocの検証コードベースがどのような対応をしているかについて検討する。

TODO: working examples

=== raw pointer

* verusではraw pointerのデリファレンスに際して `PointsTo<T>` というtrackedな構造体(中身はPhantomData)を要求する
* `PointsTo<T>` は値の読み出し・書き込みに関する権限情報として振る舞う。たとえば

[source,rust]
----
let mut t: PointsTo<T> = ...;
ptr_mut_write(ptr, Tracked(&mut t), ...);
ptr_mut_write(ptr, Tracked(&mut t), ...); // borrow fails
----

* `PointsTo<T>` はアロケーションの際に発行される

=== linked list

* メモリアロケータで扱うようなアロケーションヘッダに埋め込まれたリンクリストに関する性質を議論するには、
  実装外の何らかの手段でポインタの先に格納されている情報とその所有権に関する情報を追跡する必要がある。
* 既存の実装ではリストの先頭を保持する構造体にGhostとして、リスト上にあるすべてのノードへのポインタと
  その権限情報を保持しておくという方針が取られている

[source,rust]
----
struct Node { next: *mut Node }
struct LL {
    first: *mut Node,
    tracked perms: Tracked<Map<nat,PointsTo<Node>>
}
----


=== axiomization

* メモリアロケータはOSなどに割り当てられたメモリプールからメモリを分割していく
* このメモリプールの正当性は最初に認める必要がある
* またこのメモリプールの正当性から分割された各メモリ領域の正当性を演繹できる仕組みが必要
*  cf. `verified-memory-allocator/verus-mimalloc/os_mem.rs`
* Verusではアロケータからしか `PPtr` を作れないためアロケータのメモリプールをブートストラップ出来ないが、
  先行研究では配列から作れるようなworkaroundがされている(cf. atmosphere kernel)

== limitations

* raw pointer越しに構造体のフィールドを部分的に更新できない
